单例模式

所谓类的单例模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个获取其对象实例的方法（静态方法）

单例模式有八种方式：

1）饿汉式（静态常量）
2）饿汉式（静态代码块）
3）懒汉式（线程不安全）
4）懒汉式（线程安全，同步方法）
5）懒汉式（线程安全，同步代码块）
6）双重检查
7）静态内部类
8）枚举

单例模式的注意事项和细节说明
1）单例模式保证了系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能
2）当想要实例化一个单例类的时候，必须要记住使用相应的获取对象的方法，而不是使用new
3）单例模式使用的场景:需要频繁的进行创建和销毁的对象、创建对象时耗时过多或者耗费资源过多（即：重量级对象），
      但是又经常用到的对象、工具类duixiang、频繁访问数据库或文件的对象（比如数据源、session工厂等）



type1
饿汉式（静态常量）
步骤如下：
1）构造器私有化
2）类的内部创建对象
3）向外暴露一个静态的公共方法。getInstance
4）代码实现
优缺点：
1）优点：这种写法比较简单，就是在类装载的时候就完成实例化。避免了线程同步问题。
2）缺点：在类装载的时候就完成实例化，没有达到lazy loading的效果。如果从开始至终从未使用过这个实例，则会造成内存的浪费
3）这种方式基于classloader机制避免多线程的同步问题，不过，instance在类装载时就实例化，在单例模式中大多数都是调用getInstance方法，但是导致
	类装载的原因有很多种，因此不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化instance就没有达到lazy loading的效果。
4）结论：这种单例模式可用，可能造成内存浪费


type2
饿汉式（静态代码块）
优缺点：
1）这种方式和上面的方式其实类似，只不过将类实例化的过程放在了静态代码块中，也是在类装载的时候，就执行静态代码块中的代码，初始化类的实例。优缺点和上面是一样的。
2）结论：这种单例模式可用，可能造成内存浪费

type3
懒汉式（线程不安全）
优缺点
1）起到了lazy loading的效果，但是只能在单线程下使用。
2）如果在多线程下，一个线程进入了if (singleton == null)判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。
     所以在多线程环境下不可以使用这种方式
3）结论：在实际开放中，不要使用这种方式

type4
懒汉式（线程安全，同步方法）
优缺点
1）解决了线程不安全问题
2）效率太低，每个线程在获取实例的时候，执行getInstance方法都要进行同步等待。
3）结论：在实际开发中，不推荐使用这种方式

type5
懒汉式（线程安全，同步代码块）
优缺点
1）这种方式，本意是想对第四种方式改进
2）单这种同步并不起到线程安全作用。上边一样假如一个线程进入了if(instance = null)判断语句，还未来得及往下执行，另一个线程也通过了这个判断，这是就产生多实例
3）结论：在实际开发中，不能使用这种方式

type6
双重检查
优缺点
1）Double-Check概念是多线程开发中常常使用到的，如代码中所示，我们进行了两次if(instance==null)检查，这样就就保证线程安全了。
2）这样，实例化代码只用执行一次，后面再次访问时，判断if(instance==null)直接return实例化对象，也避免了反复进行方法同步
3）线程安全；延迟加载；效率较高
4）结论：在实际开发中，推荐使用这种单例设计模式

type7
静态内部类
静态内部类特点：外部类被装载的时候静态内部类是不会被装载的
优缺点：
1）这种方式采用了类装载的机制来保证初始化实例时只有一个线程。
2）静态内部类方式在Singleton类被装载时Singleton并没有被立即实例化，而是在需要实例化的时候，调用getInstance方法，才会装载静态内部类SingletonInstance，
	从而完成Singleton的实例化
3）类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM帮助我们保证了线程的安全性，在类进行初始化时，别的线程是无法进入的。
4）优点：避免了线程不安全，利用静态内部类特点实现延时加载，效率高
5）结论：推荐使用

type8
枚举
优缺点
1）这借助JDK1.5中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象。
2）这种方式是Effective Java作者Josh Bloch提倡的方式
3）结论：推荐使用




